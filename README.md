## Язык L

### Задание: 
- [Абстрактный синтаксис языка L](https://github.com/kajigor/fl-2022-itmo-spr/blob/proj/lang/L.md)
- [Создание конкретного синтаксиса](https://github.com/kajigor/fl-2022-itmo-spr/blob/proj/task/ConcreteSyntax.md)
- [Синтаксический анализатор](https://github.com/kajigor/fl-2022-itmo-spr/blob/proj/task/Parser.md)
- [Поддержка в среде разработки](https://github.com/kajigor/fl-2022-itmo-spr/blob/proj/task/IdeSupport.md)

### Конкретный синтаксис языка L
Пробелы и переносы строк не значащие. Комментарии начинаются с # и идут до конца строки.

Файл состоит из определений функций и определения функции main (main должен обязательно быть определён).
Определение функции всегда топ-левельное, то есть никогда не внутри другой функции. Выглядит так:
<ИМЯ_ФУНКЦИИ>(<СПИСОК_ПАРАМЕТРОВ>) { <СПИСОК_СТЕЙТМЕНТОВ> }

Параметры разделяются запятой (за последним параметром запятая не ставится), стейтменты разделяются точкой с запятой (за последним стейтментом не ставится). main не имеет параметров.

Стейтмента, который бы объявлял переменную, нет: вместо него сразу присваивание, как в питоне. Имена функций, их параметры и переменные именуются по одной и той же схеме: маленькие и большие латинские буквы, подчёрки, и цифры (имена не начинаются с цифр).

Строковые литералы: в двойных кавычках, без переносов строк внутри, внутри разрешены \n \r \t \\ \".
Десятичные числа -- любая непустая последовательность десятичных цифр. Двоичные числа начинаются с 0b, затем непустая последовательность нулей и единиц. Ограничений по длине нет.

Стейтмент: 
- skip
- <УСЛОВНЫЙ_ОПЕРАТОР>
- <ЦИКЛ>
- <ВЫЗОВ_ФУНКЦИИ>
- <ПРИСВАИВАНИЕ>
- { <СПИСОК_СТЕЙТМЕНТОВ> }

Условный оператор: 
- if (<ВЫРАЖЕНИЕ>) <СТЕЙТМЕНТ>
- if (<ВЫРАЖЕНИЕ>) <СТЕЙТМЕНТ> else <СТЕЙТМЕНТ>

Цикл: 
- while (<ВЫРАЖЕНИЕ>) <СТЕЙТМЕНТ>

Вызов функции: 
- <ИМЯ_ФУНКЦИИ>(<СПИСОК_ВЫРАЖЕНИЙ>)

Выражения разделяются запятой, за последним выражением запятая не ставится. main вызывать можно

Присваивание: 
- <ИМЯ_ПЕРЕМЕННОЙ> = <ВЫРАЖЕНИЕ>

Выражение: 
- (<ВЫРАЖЕНИЕ>)
- <ВЫРАЖЕНИЕ> <БИНАРНЫЙ_ОПЕРАТОР> <ВЫРАЖЕНИЕ>
- <УНАРНЫЙ_ОПЕРАТОР> <ВЫРАЖЕНИЕ>
- <ВЫЗОВ_ФУНКЦИИ>
- <ИМЯ_ПЕРЕМЕННОЙ>
- <ИМЯ_ФУНКЦИИ>


Причём main тоже может быть выражением (как частный случай имени функции)

Пример кода:
```
my_fun1() {
  print(x) # комментарий
}

my_fun2(x, y) {
  a = fn(fn(x), fn, main);
  if (x) return(x + y - "Hello") # return не является ключевым словом, считаем что это какая-то функция из stdlib
  else return(y+1);
  skip
}

main() {
  x = 0b1010;
  while (x) {
    my_fun1();
    someVar1 = my_fun2(x, x^2)
  };
  my_fun3()
}

my_fun3() {
  x = 1 + 2 * 3 / 4 ^ 5 || 6 && 7 || 8 && ! 9 == 10;
  y = (1 + ((2 * 3) / (4 ^ 5))) || ((6 && 7) || (8 && (! (9 == 10))))
}
```

### Синтаксический анализатор
В ветке [parser-tool](https://github.com/borisPristupa/fl-2022-itmo-spr-L-IDE/tree/parser-tool)

### Поддержка в IntelliJ IDEA
В ветке [ide-support](https://github.com/borisPristupa/fl-2022-itmo-spr-L-IDE/tree/ide-support)


Все инструкции по запуску есть в соответствующих ветках